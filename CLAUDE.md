# CRAFT 项目 Claude Code 开发规范

> CRAFT Runs Any Framework Technology - AI 驱动的跨平台 API 适配层生成系统

## 项目概述

CRAFT 使用 AI 自动化生成跨平台 API 转接层（如 Android API 到 HarmonyOS API）。项目使用 Rust 语言构建，以确保内存安全、高性能和可验证性。

## 技术栈

- **语言**: Rust 1.75+
- **AI 引擎**: Claude API (Opus 4.5)
- **解析器**: tree-sitter (Java/ArkTS 语法解析)
- **异步运行时**: Tokio
- **并行计算**: Rayon
- **模板引擎**: Tera (Jinja2 兼容)
- **序列化**: serde + serde_yaml + serde_json
- **HTTP 客户端**: reqwest
- **CLI**: clap
- **日志**: tracing

## Cargo Workspace 结构

```
CRAFT/
├── Cargo.toml              # Workspace 根配置
├── crates/
│   ├── craft-core/         # 核心数据结构
│   ├── craft-parser/       # SDK 解析器
│   ├── craft-analyzer/     # 语义分析引擎
│   ├── craft-generator/    # 代码生成器
│   ├── craft-ai/           # Claude API 集成
│   ├── craft-pipeline/     # 批处理流水线
│   └── craft-cli/          # 命令行工具
├── specs/                  # API 规格文件
├── templates/              # 代码模板
├── configs/                # 配置文件
└── output/                 # 生成产物
```

## 开发规范

### 1. Rust 代码风格

遵循 Rust 官方风格指南：

```rust
// 使用 Result 进行错误处理
pub fn parse_api(source: &str) -> Result<ApiSpec, ParseError> {
    // ...
}

// 使用 derive 宏简化代码
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ApiSpec {
    pub platform: Platform,
    pub package: String,
    pub class_name: String,
}

// 使用 impl 块组织方法
impl ApiSpec {
    pub fn new(platform: Platform, package: &str) -> Self {
        // ...
    }
}
```

### 2. API 规格文件规范

API 规格使用 YAML 格式，存放在 `specs/` 目录：

```yaml
# specs/android/android.app.Activity.yaml
api_spec:
  platform: android
  package: android.app
  class: Activity
  methods:
    - name: methodName
      signature: "returnType methodName(params)"
      semantic_tags: [tag1, tag2]
```

### 3. 映射规则规范

映射规则存放在 `configs/mapping_rules.yaml`：

```yaml
mappings:
  - source:
      platform: android
      class: android.app.Activity
    target:
      platform: harmony
      class: ohos.app.UIAbility
    mapping_type: direct  # direct | semantic | bridge
    confidence: 0.95
```

### 4. 代码生成规范

生成的适配器代码必须包含元数据注释：

```java
/**
 * Auto-generated by CRAFT v{version}
 * Source: {android_class}
 * Target: {harmony_class}
 * Confidence: {confidence}
 * Generated: {timestamp}
 *
 * DO NOT EDIT MANUALLY - regenerate using CRAFT pipeline
 */
```

### 5. 错误处理规范

使用 thiserror 定义错误类型：

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum CraftError {
    #[error("Parse error: {0}")]
    Parse(#[from] ParseError),

    #[error("API error: {0}")]
    Api(#[from] ApiError),

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
}
```

### 6. 测试规范

每个 crate 必须有完整的测试覆盖：

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_api_parsing() {
        let spec = ApiSpec::parse("...").unwrap();
        assert_eq!(spec.class_name, "Activity");
    }

    #[tokio::test]
    async fn test_async_generation() {
        // 异步测试
    }
}
```

### 7. 提交规范

```bash
# 适配器生成
feat(generator): add Activity adapter generation

# 映射规则更新
feat(analyzer): add semantic mapping for Toast API

# 流水线改进
fix(pipeline): improve batch processing stability

# 文档更新
docs: update API mapping specification
```

## AI 使用策略

根据任务复杂度选择合适的 AI 策略：

| 复杂度 | 策略 | 模型 |
|--------|------|------|
| 低 | 规则匹配 | 无 |
| 中低 | 轻量验证 | Haiku |
| 中 | 标准生成 | Sonnet |
| 高 | 高级生成 | Opus |

## 质量门禁

代码合并前必须通过：

- [ ] `cargo fmt --check` 格式检查
- [ ] `cargo clippy -- -D warnings` 静态分析
- [ ] `cargo test --all` 单元测试
- [ ] 代码覆盖率 > 80%
- [ ] 无 unsafe 代码（除非必要且有注释说明）
- [ ] 文档同步更新

## 常用命令

```bash
# 构建项目
cargo build --release

# 运行测试
cargo test --all

# 格式化代码
cargo fmt

# 静态分析
cargo clippy

# 生成文档
cargo doc --open

# 运行 CLI
cargo run --bin craft-cli -- --help

# 解析 SDK
cargo run --bin craft-cli -- parse --platform android --sdk-path /path/to/sdk

# 生成适配器
cargo run --bin craft-cli -- generate --package android.app

# 运行流水线
cargo run --bin craft-cli -- pipeline --mode incremental
```

## 性能优化

1. **使用 Rayon 进行并行处理**：
   ```rust
   use rayon::prelude::*;

   apis.par_iter()
       .map(|api| process_api(api))
       .collect()
   ```

2. **使用 Tokio 进行异步 I/O**：
   ```rust
   let results = futures::future::join_all(
       apis.iter().map(|api| async move {
           fetch_api_info(api).await
       })
   ).await;
   ```

3. **使用 tree-sitter 进行高性能解析**：
   - 增量解析支持
   - 内存高效
   - 多语言支持

## 注意事项

1. **不要手动修改** `output/` 目录下的生成文件
2. **优先更新映射规则**，而不是直接修改生成逻辑
3. **保持 API 规格的准确性**，这是所有生成的基础
4. **测试先行**：新增映射规则前先编写测试用例
5. **避免 unsafe**：除非绝对必要，否则不使用 unsafe 代码
6. **文档注释**：公开 API 必须有 `///` 文档注释
